// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Multi-tenant architecture with row-level security
model Tenant {
  id          String   @id @default(cuid())
  name        String
  domain      String?  @unique
  logo        String?
  website     String?
  industry    String?
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  users                User[]
  aiConfigs            AIConfig[]
  autoPilotConfigs     AutoPilotConfig[]
  brandAssets          BrandAsset[]
  posts                Post[]
  contentSources       ContentSource[]
  linkedinIntegrations LinkedInIntegration[]
  invitations          Invitation[]
  aiLearningData       AILearningData[]
  brandTrainingData    BrandTrainingData[]
  subscriptions        Subscription[]
  invoices             Invoice[]
  cloudStorageIntegrations CloudStorageIntegration[]
  syncedMedia          SyncedMedia[]
  mediaGroups          MediaGroup[]

  @@map("tenants")
}

// User roles: SUPER_ADMIN, TENANT_ADMIN, EDITOR, VIEWER
enum UserRole {
  SUPER_ADMIN
  TENANT_ADMIN
  EDITOR
  VIEWER
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  password      String?   // Hashed password for credentials login (optional for OAuth users)
  avatar        String?
  role          UserRole  @default(VIEWER)
  tenantId      String?   // Optional for SUPER_ADMIN - they can access all tenants
  emailVerified DateTime? // Email verification timestamp
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  tenant      Tenant?      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  posts       Post[]
  invitations Invitation[]

  @@map("users")
}

// AI Configuration per tenant
model AIConfig {
  id              String  @id @default(cuid())
  tenantId        String  @unique
  selectedModel   String  @default("gpt-4-turbo") // gpt-4-turbo, claude-3-opus, gemini-pro
  brandVoice      String? // Custom brand voice instructions
  tonePreference  String  @default("professional") // professional, casual, enthusiastic, technical
  postLength      String  @default("medium") // short, medium, long
  hashtagStrategy String  @default("moderate") // minimal, moderate, extensive
  includeEmojis   Boolean @default(true)
  includeCTA      Boolean @default(true)

  // Brand Variables for dynamic replacement in AI prompts
  companyName    String? // e.g., "TechFlow Solutions"
  companyTagline String? // e.g., "Empowering businesses with AI"
  targetAudience String? // e.g., "B2B SaaS companies, tech startups"
  keyProducts    String? // e.g., "AI Analytics Platform, Customer Insights Dashboard"
  uniqueValue    String? // e.g., "40% faster implementation, 24/7 support"
  foundedYear    String? // e.g., "2020"
  teamSize       String? // e.g., "50-100 employees"
  headquarters   String? // e.g., "San Francisco, CA"

  // Additional AI Instructions - Custom context for AI to consider
  additionalInstructions String? @db.Text // Free-form text for custom AI instructions

  // Custom Image Styles - Tenant-specific image generation styles
  imageStyles Json? // { styles: [{ id, name, prompt, isDefault, isActive }] }
  defaultImageStyle String @default("professional") // Default style to use
  
  // Image Generation Provider - Select which AI to use for image generation
  imageProvider String @default("dalle3") // dalle3, flux-pro, flux-schnell, sdxl, leonardo

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("ai_configs")
}

// Auto-Pilot configuration per tenant
model AutoPilotConfig {
  id                  String   @id @default(cuid())
  tenantId            String   @unique
  enabled             Boolean  @default(false)
  postsPerWeek        Int      @default(5)
  confidenceThreshold Float    @default(0.8) // 0.0 to 1.0
  autoSchedule        Boolean  @default(true)
  preferredTimes      String[] // ["09:00", "12:00", "17:00"]
  topics              String[] // ["AI", "Technology", "Business"]
  
  // Drive Sync Settings
  enableDriveSync      Boolean @default(false)
  driveAutoAnalyze     Boolean @default(true)
  driveAutoGenerate    Boolean @default(false)
  driveAutoApprove     Boolean @default(false)
  
  // Media Grouping Rules
  groupingEnabled      Boolean @default(true)
  
  // GUIDELINE 1: Same Day Grouping
  sameDayGrouping      Boolean @default(true)
  sameDayMaxMedia      Int @default(10)
  
  // GUIDELINE 2: Sequential Upload
  sequentialGrouping   Boolean @default(true)
  sequentialTimeWindow Int @default(3) // Hours
  
  // GUIDELINE 3: Similar Topics
  similarTopicsGrouping Boolean @default(true)
  topicSimilarityThreshold Float @default(0.6) // 60%
  
  // GUIDELINE 4: Same Event Detection
  eventDetection       Boolean @default(true)
  eventKeywords        String[] @default([])
  
  // GUIDELINE 5: Folder-based Grouping
  folderGrouping       Boolean @default(false)
  watchFolders         String[] @default([])
  
  // Media limits per post
  minMediaPerPost      Int @default(1)
  maxMediaPerPost      Int @default(10)
  
  // Story preferences
  preferStoryArc       Boolean @default(true)
  enableChronological  Boolean @default(true)
  
  // Advanced settings
  skipSingleMedia      Boolean @default(false)
  mergeRelatedGroups   Boolean @default(false)
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("autopilot_configs")
}

// Brand assets (logos, watermarks)
model BrandAsset {
  id                String   @id @default(cuid())
  tenantId          String
  name              String
  type              String // logo, watermark, template
  fileUrl           String
  fileSize          Int?
  mimeType          String?
  isDefault         Boolean  @default(false)
  watermarkSettings Json? // position, opacity, size settings
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("brand_assets")
}

// Content sources (RSS, competitor monitoring, news)
model ContentSource {
  id          String    @id @default(cuid())
  tenantId    String
  name        String
  type        String // rss, website, competitor, news
  url         String
  isActive    Boolean   @default(true)
  lastChecked DateTime?
  settings    Json? // scraping settings, keywords, etc.
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  posts  Post[] // Posts inspired by this source

  @@map("content_sources")
}

// LinkedIn profile types
enum LinkedInProfileType {
  PERSONAL
  COMPANY_PAGE
}

// LinkedIn integration per tenant (supports multiple profiles)
model LinkedInIntegration {
  id           String               @id @default(cuid())
  tenantId     String
  accessToken  String
  refreshToken String?
  expiresAt    DateTime?
  linkedinId   String
  profileName  String?
  profileImage String?
  profileType  LinkedInProfileType  @default(PERSONAL)
  
  // Company page specific fields
  organizationId   String?  // LinkedIn Organization ID
  organizationName String?  // Company name
  organizationUrn  String?  // urn:li:organization:{id}
  
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Compound unique: same tenant can have multiple profiles, but not duplicate LinkedIn IDs
  @@unique([tenantId, linkedinId])
  @@map("linkedin_integrations")
}

// Posts with AI generation tracking
enum PostStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  SCHEDULED
  PUBLISHED
  FAILED
}

model Post {
  id              String     @id @default(cuid())
  tenantId        String
  userId          String
  title           String?
  content         String
  mediaUrls       String[] // Array of image/video URLs
  scheduledAt     DateTime?
  publishedAt     DateTime?
  status          PostStatus @default(DRAFT)
  platform        String     @default("linkedin")
  linkedinPostUrl String? // URL of published post on LinkedIn

  // AI Generation metadata
  aiGenerated    Boolean @default(false)
  aiModel        String?
  aiConfidence   Float? // 0.0 to 1.0
  originalPrompt String?
  generationTime Int? // SECONDS (not milliseconds)

  // User feedback for learning
  userApproved      Boolean?
  userModifications String? // What user changed
  engagementScore   Float? // Actual performance

  // RSS Source Tracking
  contentSourceId String? // Link to ContentSource that inspired this
  rssItemTitle    String? // Original RSS item title
  rssItemUrl      String? // Original RSS item URL
  rssItemDate     DateTime? // When RSS item was published
  
  // Drive Media Tracking
  syncedMediaId  String? // Link to single synced media (legacy)
  mediaGroupId   String? // Link to the media group that generated this post
  mediaOrder     Int[]  @default([]) // Explicit order for displaying media [0, 2, 1]
  storyArcType   String? // CHRONOLOGICAL, BEFORE_AFTER, COMPARISON, COLLECTION

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant        Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  contentSource ContentSource? @relation(fields: [contentSourceId], references: [id], onDelete: SetNull)
  syncedMedia   SyncedMedia[]
  mediaGroups   MediaGroup[]

  @@map("posts")
}

// AI Learning data for continuous improvement
model AILearningData {
  id               String   @id @default(cuid())
  tenantId         String
  postId           String? // Related post if applicable
  contentSourceId  String? // Related content source if RSS inspiration
  interactionType  String // user_edit, approval, rejection, regeneration, content_inspiration
  originalContent  String?
  modifiedContent  String?
  userFeedback     String?
  improvementScore Float? // How much this improved AI accuracy
  patternDetected  String? // What pattern was learned
  rssItemUrl       String? // URL of RSS item (for content_inspiration)
  createdAt        DateTime @default(now())

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("ai_learning_data")
}

// Team invitations
enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

model Invitation {
  id        String           @id @default(cuid())
  email     String
  role      UserRole
  tenantId  String
  invitedBy String
  status    InvitationStatus @default(PENDING)
  expiresAt DateTime
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Relations
  tenant  Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  inviter User   @relation(fields: [invitedBy], references: [id], onDelete: Cascade)

  @@unique([email, tenantId])
  @@map("invitations")
}

// Brand training data from website scraping
model BrandTrainingData {
  id          String   @id @default(cuid())
  tenantId    String
  sourceUrl   String
  content     String   @db.Text
  category    String // 'about', 'products', 'services', 'values', 'tone', 'general'
  lastUpdated DateTime @default(now()) @updatedAt
  createdAt   DateTime @default(now())

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("brand_training_data")
}

// Subscription plans enum
enum SubscriptionPlan {
  FREE
  STARTER
  PROFESSIONAL
  ENTERPRISE
}

enum SubscriptionStatus {
  ACTIVE
  TRIAL
  CANCELLED
  EXPIRED
  PAST_DUE
}

// Subscription management for SaaS billing
model Subscription {
  id       String             @id @default(cuid())
  tenantId String             @unique
  plan     SubscriptionPlan   @default(FREE)
  status   SubscriptionStatus @default(TRIAL)

  // Billing cycle and amount
  amount        Float  @default(0) // Amount in dollars (e.g., 29.00 for $29)
  billingCycle  String @default("monthly") // "monthly" or "yearly"
  
  // Current billing period
  currentPeriodStart DateTime @default(now())
  currentPeriodEnd   DateTime?
  trialEndsAt        DateTime?

  // Legacy fields (keep for backward compatibility)
  startDate       DateTime  @default(now())
  endDate         DateTime?
  trialEndDate    DateTime?
  lastBillingDate DateTime?
  nextBillingDate DateTime?
  canceledAt      DateTime?

  // Stripe integration (optional - for production)
  stripeCustomerId      String?
  stripeSubscriptionId  String?
  stripePriceId         String?
  stripePaymentMethodId String?

  // Usage limits per plan
  postsLimit     Int @default(5) // FREE: 5, STARTER: 50, PRO: 200, ENTERPRISE: 9999
  usersLimit     Int @default(1) // FREE: 1, STARTER: 3, PRO: 10, ENTERPRISE: 9999
  aiCreditsLimit Int @default(10) // FREE: 10, STARTER: 500, PRO: 2000, ENTERPRISE: 9999

  // Current usage (reset monthly)
  postsUsed     Int @default(0)
  usersUsed     Int @default(0)
  aiCreditsUsed Int @default(0)

  // Usage reset tracking
  usageResetAt DateTime @default(now())

  // Billing amount (in cents, e.g., 2900 = $29.00) - DEPRECATED, use 'amount' instead
  monthlyAmount Int    @default(0) // FREE: 0, STARTER: 2900, PRO: 9900, ENTERPRISE: 29900
  currency      String @default("USD")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoices Invoice[]

  @@map("subscriptions")
}

// Invoice status enum
enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
  VOID
  DRAFT
  FAILED
  REFUNDED
  CANCELLED
}

// Invoices for billing history
model Invoice {
  id             String @id @default(cuid())
  tenantId       String // Add tenantId for direct relationship
  subscriptionId String

  // Invoice details
  invoiceNumber String        @unique // INV-2024-0001
  amount        Float // Amount in dollars (e.g., 99.00 for $99)
  currency      String        @default("USD")
  status        InvoiceStatus @default(PENDING)
  description   String? // Optional description

  // Billing period
  dueDate     DateTime
  paidAt      DateTime?

  // Stripe integration
  stripeInvoiceId String?
  stripeChargeId  String?
  invoiceUrl      String? // Stripe hosted invoice URL

  // Payment details
  paymentMethod  String? // 'card', 'bank_transfer', etc.
  lastFourDigits String? // Last 4 digits of card

  // Line items (stored as JSON for flexibility)
  lineItems Json? // [{ description: "Pro Plan", quantity: 1, amount: 9900 }]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant       Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([tenantId])
  @@map("invoices")
}

// Contact form messages (fallback when SMTP is not configured)
enum ContactMessageStatus {
  NEW
  READ
  REPLIED
  ARCHIVED
}

model ContactMessage {
  id        String               @id @default(cuid())
  name      String
  email     String
  company   String?
  subject   String
  message   String               @db.Text
  status    ContactMessageStatus @default(NEW)
  ipAddress String?
  userAgent String?
  createdAt DateTime             @default(now())
  readAt    DateTime?
  repliedAt DateTime?

  @@index([status])
  @@index([createdAt])
  @@map("contact_messages")
}

// Pricing Configuration (managed by Super Admin)
model PricingConfig {
  id        String   @id @default(cuid())
  plan      String   @unique // 'FREE', 'STARTER', 'PROFESSIONAL', 'ENTERPRISE'
  
  // Display info
  name        String
  description String
  
  // Pricing
  price        Int    // in cents
  priceDisplay String // "$29/month"
  
  // Limits
  postsLimit     Int
  usersLimit     Int
  aiCreditsLimit Int
  
  // Features (stored as JSON array)
  features Json // ["50 posts per month", "3 users", ...]
  
  // UI settings
  popular       Boolean @default(false)
  stripePriceId String? // Optional Stripe Price ID
  
  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("pricing_configs")
}

// Cloud Storage Integrations (Google Drive, OneDrive, Dropbox)
enum CloudStorageProvider {
  GOOGLE_DRIVE
  ONEDRIVE
  DROPBOX
}

model CloudStorageIntegration {
  id           String   @id @default(cuid())
  tenantId     String
  provider     CloudStorageProvider
  accessToken  String   @db.Text
  refreshToken String?  @db.Text
  expiresAt    DateTime?
  
  // Folder/path settings
  syncFolderPath String @default("/") // e.g., "/Social Media Content"
  
  // Sync settings
  isActive         Boolean  @default(true)
  lastSyncedAt     DateTime?
  lastSyncedFileId String? // Track last processed file
  
  // Auto-pilot settings
  autoAnalyze    Boolean @default(true)
  autoGenerate   Boolean @default(false)
  autoApprove    Boolean @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  tenant      Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  syncedMedia SyncedMedia[]
  
  @@unique([tenantId, provider])
  @@map("cloud_storage_integrations")
}

// Synced Media from Cloud Storage
enum MediaProcessingStatus {
  PENDING        // Just synced, not processed
  ANALYZING      // GPT-4o analyzing
  ANALYZED       // Analysis complete
  GENERATING     // Generating post
  GENERATED      // Post generated
  FAILED         // Processing failed
  SKIPPED        // User chose to skip
}

model SyncedMedia {
  id                      String   @id @default(cuid())
  tenantId                String
  cloudStorageIntegrationId String
  
  // Original file info
  originalFileName  String
  originalFileId    String // Drive/OneDrive file ID
  originalFileUrl   String // Direct download URL
  originalFolderPath String
  uploadedAt        DateTime? // When user uploaded to Drive
  
  // Downloaded/processed info
  localUrl          String? // Cloudinary URL after download
  mediaType         String  // image, video
  fileSize          Int?
  mimeType          String?
  
  // AI Analysis (INDIVIDUAL)
  aiAnalyzed        Boolean @default(false)
  aiAnalysisResult  Json?
  aiDescription     String? @db.Text
  aiSuggestedTopics String[]
  aiDetectedObjects String[] // Objects detected (person, laptop, office, etc.)
  aiMood            String?  // professional, casual, exciting, etc.
  aiContext         String?  // meeting, presentation, product demo, etc.
  
  // Grouping info
  isGrouped         Boolean @default(false)
  mediaGroupId      String?
  groupOrder        Int?    // Order within group (1, 2, 3...)
  
  // Post generation
  postGenerated     Boolean @default(false)
  postId            String?
  
  // Metadata extraction
  locationData      Json?    // GPS, location tags
  captureDate       DateTime? // When photo was taken (EXIF)
  deviceInfo        String?  // Camera/phone used
  
  // Sync tracking
  syncedAt          DateTime @default(now())
  lastProcessedAt   DateTime?
  processingStatus  MediaProcessingStatus @default(PENDING)
  errorMessage      String?
  
  tenant       Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  integration  CloudStorageIntegration @relation(fields: [cloudStorageIntegrationId], references: [id], onDelete: Cascade)
  mediaGroup   MediaGroup? @relation(fields: [mediaGroupId], references: [id], onDelete: SetNull)
  posts        Post[]
  
  @@unique([cloudStorageIntegrationId, originalFileId])
  @@index([tenantId, processingStatus])
  @@index([tenantId, isGrouped, postGenerated])
  @@map("synced_media")
}

// Media Groups for multi-image posts
enum GroupingRule {
  SAME_DAY           // Same upload day
  SIMILAR_TOPICS     // Similar semantic content
  SAME_EVENT         // Detected as same event/context
  SEQUENTIAL         // Uploaded within X hours
  SAME_FOLDER        // From same Drive folder
  MANUAL             // User manually grouped
  MIXED              // Multiple rules applied
}

enum MediaGroupStatus {
  PENDING            // Just created, not processed
  READY_FOR_POST     // Analysis complete, ready to generate post
  GENERATING         // Currently generating post
  POSTED             // Post created successfully
  SKIPPED            // User chose to skip this group
  FAILED             // Generation failed
}

enum StoryArcType {
  CHRONOLOGICAL      // Timeline of events (1 → 2 → 3)
  BEFORE_AFTER       // Transformation (before vs after)
  COMPARISON         // Side-by-side comparison
  COLLECTION         // Related items showcase
  CAROUSEL           // No specific order, just collection
}

model MediaGroup {
  id                String   @id @default(cuid())
  tenantId          String
  
  // Grouping metadata
  groupingRule      GroupingRule
  groupingReason    String?  // Human-readable explanation
  
  // Temporal info
  uploadDateStart   DateTime // Earliest upload in group
  uploadDateEnd     DateTime // Latest upload in group
  captureDate       DateTime? // When photos were actually taken
  
  // Semantic info
  commonTopics      String[] // Topics shared across all media
  detectedTheme     String?  // AI-detected overall theme
  storyArc          StoryArcType?
  
  // Quality metrics
  groupConfidence   Float @default(0.0)
  mediaCount        Int
  
  // Post generation
  status            MediaGroupStatus @default(PENDING)
  postIds           String[] @default([]) // Array of generated post IDs
  
  // Settings snapshot
  maxMediaPerPost   Int @default(10)
  minMediaPerPost   Int @default(1)
  
  createdAt         DateTime @default(now())
  processedAt       DateTime?
  
  tenant     Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  media      SyncedMedia[]
  posts      Post[]
  
  @@index([tenantId, status])
  @@index([tenantId, createdAt])
  @@map("media_groups")
}
